Your plugin’s log() callback does run for every stepped instruction (confirmed by the “fprintf worked” debug lines), so the core logging pipeline is fine. The reason /tmp/branchlog.csv shows only the header
  plus the very first instruction is that ScallopShell keeps recreating that file after QEMU starts, so the file descriptor the plugin writes to and the filename you cat point at two different inodes.

  Sequence that causes the issue:

  1. QEMU starts, the plugin opens /tmp/branchlog.csv (fopen("…", "w+")) and writes the header + first instruction. That file has inode A.
  2. ScallopShell later calls startEmulation() again (e.g., during “reset” or on another start), which opens/unlinks /tmp/branchlog.csv while QEMU is still running, creating a new inode B under the same
     pathname.
  3. QEMU’s file descriptor still points at inode A (now orphaned—no pathname in /tmp), so every fprintf goes into inode A. When you run cat /tmp/branchlog.csv, you read inode B, which contains only the
     header/first line.

  You can observe this live by running:

  pid=$(pgrep -n qemu-x86_64)
  stat -c '%i %n' /proc/$pid/fd/7
  stat -c '%i %n' /tmp/branchlog.csv

  The inode numbers differ whenever you see the bug. Removing the ofstream from startEmulation() helped once because it incidentally stopped recreating the file, but any later code path that truncates /tmp/
  branchlog.csv while QEMU still runs reintroduces the mismatch.

  To fix it without breaking the “stop on first instruction” behaviour:

  - Only truncate the CSV before launching QEMU (after killing any previous child), or
  - Give each run a unique filename (/tmp/branchlog.<pid>.csv) and pass that path to the plugin/CLI so both sides always reference the same inode.

  Once the plugin’s fd and ScallopShell’s path refer to the same file, stepping N instructions will append N lines even though the gates remain paused by default.
